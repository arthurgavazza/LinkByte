# Leveraging MDC Files to Improve Development Workflow in Cursor

## What Are MDC Files?

MDC (Markdown Configuration) files are special documentation files used by Cursor AI to understand codebases and guide development. These files contain project-specific rules, patterns, and best practices that help the AI provide more contextual and relevant code suggestions and modifications.

When working with Cursor AI, these MDC files act as a knowledge base that shapes how the AI responds to your requests. They enable the AI to understand your project's architecture, coding standards, and patterns without having to analyze the entire codebase repeatedly.

## How MDC Files Enhance Development Workflow

MDC files significantly improve development workflow in Cursor by:

1. **Providing consistent patterns**: Ensure all team members follow the same code structure and patterns.
2. **Accelerating onboarding**: Help new developers understand project conventions quickly.
3. **Reducing cognitive load**: Document complex patterns so developers don't need to remember everything.
4. **Guiding AI assistance**: Enable Cursor AI to provide more relevant and accurate code suggestions.
5. **Enforcing best practices**: Codify project-specific standards and best practices.

## Organizing Rules with cursor-rules.mdc

The `cursor-rules.mdc` file serves as a meta-rule that helps organize and structure all other rules. It provides guidelines on how to:

- Structure rule content concisely (15-25 lines of content)
- Focus each rule on a single topic or technology
- Use bullet points instead of paragraphs
- Include minimal code examples
- Organize files with proper naming conventions

This meta-rule approach helps keep your rules organized and maintainable. By following the structure defined in `cursor-rules.mdc`, you ensure that all other rules remain focused, specific, and easy to update.

According to the rule, MDC files should be organized with proper prefixes:
- `core-`: Project-wide standards
- `fe-`: Frontend guidelines
- `be-`: Backend guidelines
- `test-`: Testing practices
- `tool-`: Tool-specific guidelines

This organization makes it easy to find relevant rules when needed and ensures that the AI can pick up the right context for different parts of your codebase.

## A Real-World Example: Analyzing the CreateLinkModal Component

Let's examine a real-world component to see how MDC rules can help improve code quality and adherence to project standards. Below is a `CreateLinkModal` component from our URL shortener application, it was initially generated by Vercel's V0 and it didn't follow our repository guidelines and it didn't implement real API calls:

## Identifying Issues with the Component

Looking at the `CreateLinkModal` component, we can see that it doesn't follow several rules defined in our MDC files:

### Violations of `form-api-patterns.mdc` Rule:

1. **Not using React Hook Form with Zod validation**:
   - The component uses manual state management with multiple `useState` hooks
   - Form validation is handled manually instead of using Zod schemas
   - No structured form state management

2. **No API integration with Orval-generated hooks**:
   - Direct API calls instead of using generated hooks
   - Missing proper API error handling patterns
   - No React Query integration for cache management

### Violations of `fe-component-patterns.mdc` Rule:

1. **Component has multiple responsibilities**:
   - Form state management
   - Form validation
   - API integration
   - UI rendering
   - Should extract form logic to a custom hook

2. **No separation of presentation and logic**:
   - UI and business logic are tightly coupled
   - No abstraction of form handling

### Violations of `core-code-quality.mdc` Rule:

1. **Functions are too large**:
   - `handleSubmit` function handles multiple concerns
   - Component is over 400 lines of code
   - Several functions exceed the recommended limit of 20 lines

2. **Too many state variables**:
   - 11+ separate state hooks when they could be combined
   - Deep nesting in conditional rendering
   - Complex state interactions

## How Cursor AI Refactored the Component

Using our MDC rules as a guide, Cursor AI refactored the CreateLinkModal component to align with our project's best practices. The transformation shows how Cursor directly applied the patterns defined in our rules.

### Original Component

The original `CreateLinkModal` component had several issues that didn't follow our standard patterns:

```tsx
// Original component with multiple useState hooks
export function CreateLinkModal({ isOpen, onClose }: CreateLinkModalProps) {
  // Multiple useState hooks for form state 
  // Violates fe-component-patterns.mdc rule about keeping components focused
  const [isLoading, setIsLoading] = useState(false)
  const [longUrl, setLongUrl] = useState("")
  const [customAlias, setCustomAlias] = useState("")
  const [isPasswordProtected, setIsPasswordProtected] = useState(false)
  const [password, setPassword] = useState("")
  const [expirationEnabled, setExpirationEnabled] = useState(false)
  const [expirationDate, setExpirationDate] = useState<Date | undefined>(undefined)
  const [tags, setTags] = useState<string[]>([])
  const [currentTag, setCurrentTag] = useState("")
  const [shortUrl, setShortUrl] = useState("")
  const [showAdvanced, setShowAdvanced] = useState(false)
  const [utmParams, setUtmParams] = useState({
    source: "",
    medium: "",
    campaign: "",
    term: "",
    content: "",
  })
  const [errors, setErrors] = useState({
    longUrl: "",
    customAlias: "",
    password: "",
  })

  // Manual form validation - doesn't follow form-api-patterns.mdc rule
  const validateForm = () => {
    const newErrors = {
      longUrl: "",
      customAlias: "",
      password: "",
    }
    let isValid = true

    if (!longUrl) {
      newErrors.longUrl = "URL is required"
      isValid = false
    } else {
      try {
        new URL(longUrl)
      } catch (e) {
        newErrors.longUrl = "Please enter a valid URL including http:// or https://"
        isValid = false
      }
    }

    // More validation logic...
    
    setErrors(newErrors)
    return isValid
  }

  // Direct API call - doesn't follow form-api-patterns.mdc rule about Orval hooks
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault()

    if (!validateForm()) {
      return
    }

    setIsLoading(true)

    try {
      // API call without using Orval-generated hooks
      const result = await shortenUrl({
        longUrl: finalLongUrl,
        customAlias: customAlias || undefined,
        password: isPasswordProtected ? password : undefined,
        expirationDate: expirationEnabled && expirationDate ? expirationDate.toISOString() : undefined,
      })

      setShortUrl(result.shortUrl)
      // Toast notification without React Query cache invalidation
    } catch (error) {
      // Error handling
    } finally {
      setIsLoading(false)
    }
  }

  // Return JSX
}
```

### Refactored Component

Cursor AI refactored the component to follow our rules, resulting in a more maintainable implementation:

```tsx
// Refactored component using React Hook Form, Zod, and Orval
export function CreateLinkModal({ isOpen, onClose }: CreateLinkModalProps) {
  const queryClient = useQueryClient()
  
  // Following form-api-patterns.mdc: "Use React Hook Form with Zod validation"
  const createLinkSchema = z.object({
    original_url: z.string().url({ message: "Please enter a valid URL including http:// or https://" }),
    custom_alias: z.string().regex(/^[a-zA-Z0-9_-]*$/, {
      message: "Custom alias can only contain letters, numbers, underscores and hyphens",
    }).optional(),
    // Other schema validations...
  });

  type FormValues = z.infer<typeof createLinkSchema>;

  // Consolidated state management with React Hook Form
  // Following fe-component-patterns.mdc: "Keep components focused on a single responsibility"
  const form = useForm<FormValues>({
    resolver: zodResolver(createLinkSchema),
    defaultValues: {
      original_url: "",
      custom_alias: "",
      is_password_protected: false,
      // Other default values...
    }
  });

  // Following form-api-patterns.mdc: "Use Orval-generated hooks for API calls"
  const createLinkMutation = useCreateLinkApiLinksPost({
    mutation: {
      onSuccess: (data) => {
        const shortUrl = `http://localhost:8000/api/r/${data.short_code}`;
        
        // First close the modal and reset the form
        onClose();
        form.reset();
        
        // Show toast with the URL and copy action
        toast.success("URL shortened successfully", {
          // Success toast content
        });
        
        // Following form-api-patterns.mdc: "Use React Query's cache management"
        queryClient.invalidateQueries({ queryKey: ['/api/links/'] });
      },
      onError: (error: any) => {
        // Following form-api-patterns.mdc: "Implement error handling with toast notifications"
        toast.error("Error shortening URL", {
          description: error.response?.data?.detail || "Please try again with a valid URL."
        });
      }
    }
  });

  // Following core-code-quality.mdc: "Write small, focused functions (<20 lines)"
  const onSubmit = (values: FormValues) => {
    try {
      // Prepare data for API call
      
      // Use the Orval-generated mutation
      createLinkMutation.mutate({
        data: {
          original_url: finalLongUrl,
          custom_alias: values.custom_alias || undefined,
          is_password_protected: values.is_password_protected,
          // Other values...
        }
      });
    } catch (error) {
      // Error handling
    }
  };

  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent>
        <DialogHeader>
          <DialogTitle>Create New Link</DialogTitle>
          <DialogDescription>Shorten a URL and customize its settings.</DialogDescription>
        </DialogHeader>

        {/* Following fe-component-patterns.mdc: "Use Form components for proper field rendering" */}
        <Form {...form}>
          <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-4 py-4">
            <FormField
              control={form.control}
              name="original_url"
              render={({ field }) => (
                <FormItem className="space-y-2">
                  <FormLabel>Long URL</FormLabel>
                  <FormControl>
                    <Input
                      type="url"
                      placeholder="https://example.com/very/long/url/that/needs/shortening"
                      {...field}
                    />
                  </FormControl>
                  <FormMessage />
                </FormItem>
              )}
            />

            {/* Other form fields... */}
            
            {/* Conditional rendering based on form state */}
            {form.watch("showAdvanced") && (
              <Tabs defaultValue="protection" className="w-full">
                {/* Tab content... */}
              </Tabs>
            )}

            <DialogFooter>
              <Button type="button" variant="outline" onClick={onClose}>
                Cancel
              </Button>
              <Button
                type="submit"
                disabled={createLinkMutation.isPending}
              >
                {createLinkMutation.isPending ? "Creating..." : "Create Link"}
              </Button>
            </DialogFooter>
          </form>
        </Form>
      </DialogContent>
    </Dialog>
  );
}
```

## The Key Improvements

The refactored component demonstrates how our MDC rules guided Cursor AI to implement several key improvements:

1. **Structured Form Handling** - Following `form-api-patterns.mdc`, the component now uses React Hook Form with Zod validation, providing automatic validation and simplified state management.

2. **API Integration** - Following `form-api-patterns.mdc`, the component uses Orval-generated hooks for API calls with proper error handling and React Query cache invalidation.

3. **State Management** - Following `fe-component-patterns.mdc`, multiple useState hooks were replaced with a single form state, making the component more maintainable.

4. **Component Structure** - Following `fe-component-patterns.mdc`, the component uses proper form components and keeps UI and logic better organized.

5. **Function Design** - Following `core-code-quality.mdc`, functions are more focused and have clear responsibilities.

These improvements show how MDC files effectively guided the AI to implement code that follows our project's standards and best practices. The cursor rules provided explicit direction on how to structure forms, handle API calls, and organize component code, resulting in a more maintainable implementation.

## Creating and Using Cursor Rules for Development

Cursor rules are a powerful way to guide the AI assistant in following project-specific patterns and best practices. In our project, we've created a comprehensive set of rules that help maintain consistency and quality across our codebase.

### What Are Cursor Rules?

According to the [official Cursor documentation](https://docs.cursor.com/context/rules), rules allow you to "provide system-level guidance to the Agent and Cmd-K AI." They serve as persistent instructions that help the AI understand your project's architecture, standards, and workflows.

Large language models don't retain memory between completions, and rules solve this by providing consistent context at the prompt level. When a rule is applied, its contents are included at the start of the model context, giving the AI consistent guidance whether it's generating code, interpreting edits, or helping with a workflow.

Cursor supports three types of rules:

1. **Project Rules**: Stored in `.cursor/rules`, version-controlled and scoped to your codebase.
2. **User Rules**: Global to your Cursor environment, defined in settings and always applied.
3. **.cursorrules (Legacy)**: Still supported but deprecated in favor of Project Rules.

### How We Created Our Rules

Our rules were developed through a multi-step process:

1. **Initial Generation**: We used [cursor.directory/generate](https://cursor.directory/generate) to analyze our `package.json` and `requirements.txt` files, generating baseline rules for our tech stack.

2. **Research and Refinement**: We incorporated best practices found online for React, Next.js, FastAPI, and other technologies we use.

3. **Standardization**: We used the `cursor-rules.mdc` meta-rule to standardize the format and structure of all our rules.

4. **Categorization**: We organized rules into clear categories (core, frontend, backend, testing, etc.) to make them easy to find and maintain.

5. **Continuous Improvement**: We regularly update rules as our project evolves and as we discover better patterns.

### Rule Structure and Formatting

Each rule file is written in **MDC** (`.mdc`), a lightweight format that supports metadata and content in a single file. According to the documentation, rules support the following types:

| Rule Type       | Description                                                                                  |
| --------------- | -------------------------------------------------------------------------------------------- |
| Always          | Always included in the model context                                                         |
| Auto Attached   | Included when files matching a glob pattern are referenced                                   |
| Agent Requested | Rule is available to the AI, which decides whether to include it. Must provide a description |
| Manual          | Only included when explicitly mentioned using @ruleName                                      |

Here's an example rule structure from our project:

```markdown
---
description: Brief, focused description (1 line)
globs: "path/pattern/**/*.{ext}" # Relevant files
alwaysApply: boolean # Whether to apply without attachment
---
# Title (H1)

## Section (H2)
- Bullet point 1
- Bullet point 2
- Bullet point 3

## Another Section (H2)
- Bullet point 1
- Bullet point 2
```

You can also reference other files in your rules using the `@filename` syntax, which includes the file's content as additional context when the rule is triggered.

Rules can be created using the "New Cursor Rule" command (`Cmd + Shift + P` > "New Cursor Rule") or through Cursor Settings > Rules.

### Types of Rules in Our Project

Our rules are organized into several categories:

#### Core Rules

These rules apply project-wide standards and practices:

- `core-project-structure.mdc`: Defines the organization of our code, ensuring consistent file layouts and naming conventions.
- `core-code-quality.mdc`: Establishes code quality standards including function size limits, variable naming, and code organization.
- `core-workflow.mdc`: Outlines our development process and workflows.

#### Frontend Rules

These rules guide frontend development:

- `fe-component-patterns.mdc`: Defines how React components should be structured, focusing on single responsibility and proper TypeScript typing.
- `fe-state-management.mdc`: Establishes patterns for state management using React hooks and context.
- `fe-nextjs.mdc`: Sets standards for Next.js application structure and features.
- `form-api-patterns.mdc`: Provides guidelines for form handling with React Hook Form and API integration.

#### Backend Rules

These rules guide backend development:

- `be-api-design.mdc`: Outlines API endpoint design principles including REST conventions and request/response patterns.
- `be-error-handling.mdc`: Defines error handling and logging practices for consistent error management.
- `be-security.mdc`: Establishes security practices for backend applications.
- `database-patterns.mdc`: Provides database model design and query optimization patterns.

#### Testing Rules

These rules ensure proper testing practices:

- `test-automation.mdc`: Guidelines for creating automated tests.
- `unit-testing.mdc`: Best practices for component and utility tests.
- `storybook-basics.mdc`: Standards for Storybook setup and component stories.
- `test-e2e-patterns.mdc`: End-to-end testing guidelines with Playwright.

#### Tool-Specific Rules

These rules provide guidance for specific technologies:

- `tool-fastapi.mdc`: Best practices for FastAPI development.
- `tool-pydantic.mdc`: Patterns for using Pydantic for data validation.
- `tool-sqlalchemy.mdc`: Guidelines for SQLAlchemy ORM and Alembic migrations.

#### Domain-Specific Rules

These rules capture knowledge about specific application domains:

- `domain-url-shortener.mdc`: Patterns specific to our URL shortener application.

#### Task Management Rules

We also use rules to help with task management:

- `task-list.mdc`: Guidelines for creating and managing task lists in markdown files.

This rule is particularly interesting as it could potentially be extended to connect with project management tools like Jira. Currently, it helps the AI maintain and update task lists within the project.

### Best Practices for Rule Usage

According to the [Cursor documentation](https://docs.cursor.com/context/rules), good rules are focused, actionable, and scoped. Here are the recommended best practices:

1. **Keep rules concise**: The documentation suggests under 500 lines as a good target.
2. **Split large concepts into multiple, composable rules**: This improves maintainability and clarity.
3. **Provide concrete examples or referenced files**: Use the `@filename` syntax to include relevant examples.
4. **Avoid vague guidance**: Write rules the way you would write clear internal documentation.
5. **Reuse rules when you find yourself repeating prompts**: If you're giving the same instructions repeatedly, make it a rule.

In our experience, we've found these additional tips helpful:

1. **Be specific**: Scope each rule to a specific aspect of development (a library, pattern, convention, etc.).
2. **Use an index**: Create an index rule (like our `rules-index.mdc`) that helps the AI understand the purpose and relationship of all rules.
3. **Provide hints**: When asking the AI to perform a task, mention relevant rules it should consider.
4. **Keep rules updated**: Regularly review and update rules as your project evolves.
5. **Use clear descriptions**: The `description` field in the frontmatter is crucial for helping the AI understand when to apply a rule.

### Finding and Creating Rules

You can find community-contributed rules at [cursor.directory/rules](https://cursor.directory/rules), which provides a wide range of examples for different technologies and frameworks.

When creating new rules, refer to the [official Cursor documentation](https://docs.cursor.com/context/rules) for the most up-to-date information on rule capabilities and best practices.

### The Impact of Rules on Development

By implementing a comprehensive set of Cursor rules, we've seen several benefits:

1. **Consistency**: All code generated by the AI follows our established patterns and conventions.
2. **Efficiency**: We spend less time correcting AI-generated code since it already aligns with our standards.
3. **Knowledge Sharing**: Rules serve as documentation for team members, capturing our best practices in a central location.
4. **Reduced Repetition**: We avoid repeating the same instructions to the AI for common tasks.

Rules have become an essential part of our development workflow, ensuring that the AI is a more effective member of our team by understanding and following our project-specific guidelines.

## Understanding How Cursor AI Works

Cursor AI, as an IDE, leverages large language models (LLMs) to enhance coding productivity by predicting and generating code. According to [Shrivu's Substack](http://blog.sshh.io/p/how-cursor-ai-ide-works), the system operates by using LLMs to predict the next word, which is then used to build complex applications. The process involves several phases, from basic coding LLMs to agentic coding, where the LLM interacts with external systems through tool calls like `read_file` and `write_file`.

### Agentic Coding

Cursor AI functions as a complex wrapper around LLMs, optimizing prompts and tools to work consistently. The IDE injects context using `@file` syntax and gathers more context through various tools, allowing the LLM to make informed coding decisions. This approach reduces cognitive load and enhances the accuracy of code generation.

### Optimizations & User Tips

- Use `@file` syntax to provide explicit context for faster responses.
- Index the codebase into a vectorstore for efficient semantic queries.
- Optimize the `write_file` tool by using semantic diffs and a code-apply LLM to handle syntax issues.
- Use unique file names and organize code hot-paths to reduce ambiguity.

## How to Effectively Use Cursor Rules

Cursor rules are a powerful way to guide the AI assistant in following project-specific patterns and best practices. According to the [official Cursor documentation](https://docs.cursor.com/context/rules), rules provide system-level guidance to the AI, ensuring consistent context at the prompt level.

### Types of Rules

Cursor supports several types of rules:

1. **Always-applied rules**: Automatically included in every conversation.
2. **File-pattern rules**: Included when files matching a pattern are referenced.
3. **Description-based rules**: Selected by the AI based on query relevance.
4. **Manually-requested rules**: Included when explicitly requested.

### Creating and Using Rules

Our rules are organized into categories such as core, frontend, backend, and testing. Each rule is written in MDC format, supporting metadata and content in a single file. The rules are concise, focused, and provide actionable guidance.

### Best Practices for Rule Usage

- **Focus on Positive Commands**: Clearly state what the AI should do, rather than what it shouldn't.
- **Avoid Overriding System Prompts**: Do not attempt to override or conflict with the system's built-in prompts.
- **Use Clear and Concise Descriptions**: Ensure that rule descriptions are clear and help the AI determine when to apply them.
- **Optimize Rule Names and Descriptions**: Use intuitive names and descriptions to help the AI understand when a rule is applicable.
- **Regularly Review and Update Rules**: Keep rules updated as the project evolves to maintain relevance and effectiveness.

By implementing a comprehensive set of Cursor rules, we ensure that the AI follows our established patterns and conventions, leading to consistent and efficient code generation.

